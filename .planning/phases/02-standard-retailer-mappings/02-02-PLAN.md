---
phase: 02-standard-retailer-mappings
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/parsers/base-parser.ts
  - src/retailers/index.ts
autonomous: true

must_haves:
  truths:
    - "Processing ACE manifest produces unified CSV with UPC as item_number"
    - "Processing AMZ manifest produces unified CSV with ASIN as item_number"
    - "Processing ATT manifest with 'NOT AVAILABLE' UPC produces blank item_number"
    - "Processing BY manifest uses Quantity column for qty"
    - "Processing TL manifest uses 'Orig. Retail' for unit_retail"
    - "All 10 retailer manifest types process through unified pipeline"
  artifacts:
    - path: "src/parsers/base-parser.ts"
      provides: "Updated parsing using retailer field configs"
      contains: "getRetailerFieldConfig"
    - path: "src/retailers/index.ts"
      provides: "Barrel export including field-mappings"
      exports: ["getRetailerFieldConfig", "isNullValue"]
  key_links:
    - from: "src/parsers/base-parser.ts"
      to: "src/retailers/field-mappings.ts"
      via: "import { getRetailerFieldConfig }"
      pattern: "import.*getRetailerFieldConfig.*from.*retailers"
    - from: "src/parsers/base-parser.ts"
      to: "src/retailers/field-mappings.ts"
      via: "import { isNullValue }"
      pattern: "import.*isNullValue.*from.*retailers"
---

<objective>
Integrate retailer field mapping configurations into the parsing pipeline so each retailer's manifest columns are correctly extracted.

Purpose: Wire the new retailer-specific field configs into base-parser.ts, replacing the generic field mapping with retailer-aware extraction that handles null values correctly.

Output: Working end-to-end parsing for all 10 retailers with proper field mapping.
</objective>

<execution_context>
@C:\Users\Shealtiel\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Shealtiel\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-standard-retailer-mappings/02-CONTEXT.md
@.planning/phases/02-standard-retailer-mappings/02-01-SUMMARY.md

Source files:
@src/parsers/base-parser.ts
@src/parsers/types.ts
@src/retailers/field-mappings.ts
@src/retailers/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update retailers/index.ts barrel export</name>
  <files>src/retailers/index.ts</files>
  <action>
    Add exports from field-mappings.ts to the barrel export file:

    ```typescript
    export { getRetailerFieldConfig, isNullValue, NULL_VALUES } from './field-mappings'
    export type { RetailerFieldConfig } from './field-mappings'
    ```

    Keep existing exports from types.ts and registry.ts unchanged.
  </action>
  <verify>
    ```bash
    grep -n "field-mappings" src/retailers/index.ts
    npx tsc --noEmit
    ```
  </verify>
  <done>retailers/index.ts exports getRetailerFieldConfig, isNullValue, and RetailerFieldConfig type</done>
</task>

<task type="auto">
  <name>Task 2: Integrate field configs into base-parser.ts</name>
  <files>src/parsers/base-parser.ts</files>
  <action>
    Update base-parser.ts to use the new retailer field configurations:

    1. Add import at top of file:
       ```typescript
       import { getRetailerFieldConfig, isNullValue } from '../retailers'
       ```

    2. Modify `getFieldMapping(site: string)` function:
       - Call `getRetailerFieldConfig(site)` to get the retailer-specific config
       - Map the RetailerFieldConfig to FieldMapping format:
         - config.itemNumber -> mapping.upc
         - config.productName -> mapping.productName
         - config.qty -> mapping.quantity
         - config.unitRetail -> mapping.unitRetail

    3. Update `extractString` function to apply null-value handling:
       - After extracting the string value, check if isNullValue(value)
       - If null value detected, return ''
       - Example: if extracted value is 'NOT AVAILABLE' and isNullValue returns true, return ''

    4. Update `extractNumber` function to handle null values:
       - Before parsing, check if string value is a null value
       - If null value, return 0

    5. Keep existing logic for column mapping (mapColumns function) - it already handles case-insensitive matching with includes

    DO NOT modify:
    - parseManifestData function signature
    - ManifestItem interface (it stays unchanged)
    - isValidItem function
    - mergeFieldMappings function
  </action>
  <verify>
    ```bash
    # TypeScript compiles
    npx tsc --noEmit

    # Build succeeds
    npm run build

    # Check imports are correct
    grep -n "getRetailerFieldConfig\|isNullValue" src/parsers/base-parser.ts
    ```
  </verify>
  <done>base-parser.ts uses retailer field configs and applies null-value handling during extraction</done>
</task>

<task type="auto">
  <name>Task 3: Verify with sample manifests</name>
  <files>tests/integration/retailer-parsing.test.ts</files>
  <action>
    Create integration test file to verify parsing of sample manifests:

    ```typescript
    import { parseManifestData } from '../../src/parsers/base-parser'
    import * as fs from 'fs'
    import * as path from 'path'
    import { parse } from 'csv-parse/sync'

    describe('Retailer Parsing Integration', () => {
      const loadCsv = (filename: string) => {
        const content = fs.readFileSync(path.join(__dirname, '../../csvs', filename), 'utf-8')
        return parse(content, { columns: true, skip_empty_lines: true })
      }

      test('ACE manifest extracts UPC as item_number', () => {
        const data = loadCsv('ACE_Outdoor-Living-LN-1100.csv')
        const items = parseManifestData(data, 'ace', 'test.csv')
        expect(items[0].upc).toBe('50904007018')
        expect(items[0].productName).toContain('SS BAYOU FRYER')
      })

      test('AMZ manifest extracts ASIN as item_number', () => {
        const data = loadCsv('AMZ_Home-Goods-UG-1108.csv')
        const items = parseManifestData(data, 'amz', 'test.csv')
        expect(items[0].upc).toBe('B0DSKC7QT7')
        expect(items[0].productName).toContain('ECOVACS')
      })

      test('ATT manifest with NOT AVAILABLE UPC produces blank', () => {
        const data = loadCsv('ATT_Chargers,-Phone-Grips,-Miscellaneo-LN-1315.csv')
        const items = parseManifestData(data, 'att', 'test.csv')
        // Row with NOT AVAILABLE should have blank upc
        const itemWithNoUpc = items.find(i => i.productName.includes('KYB SAM'))
        expect(itemWithNoUpc?.upc).toBe('')
      })

      test('BY manifest uses Quantity column', () => {
        const data = loadCsv('BY_Alka-Seltzer-Plus-Fizzy-Chews-Orang-NC-1000.csv')
        const items = parseManifestData(data, 'by', 'test.csv')
        expect(items[0].quantity).toBe(3276)
      })

      test('TGT manifest extracts UPC', () => {
        const data = loadCsv('TGT_Furniture-LN-1205.csv')
        const items = parseManifestData(data, 'tgt', 'test.csv')
        expect(items[0].upc).toBe('840307041791')
      })

      test('B-Stock manifest extracts Item #', () => {
        const data = loadCsv('B_Apple-Watches-LN-1101.csv')
        const items = parseManifestData(data, 'bstock', 'test.csv')
        expect(items[0].upc).toBe('1778325')
      })

      test('QVC manifest extracts Item #', () => {
        const data = loadCsv('QVC_Drinks-Tray-NC-1230.csv')
        const items = parseManifestData(data, 'qvc', 'test.csv')
        expect(items[0].upc).toBe('M81102')
      })

      test('RC manifest extracts Item #', () => {
        const data = loadCsv('RC_Men\\'s-2Pk-Knit-Cotton-Boxer-Briefs-NC-1100.csv')
        const items = parseManifestData(data, 'rc', 'test.csv')
        expect(items[0].upc).toBe('TFMW2BX')
      })

      test('JCP manifest extracts Brand', () => {
        const data = loadCsv('JCP_Watches-UG-1205.csv')
        const items = parseManifestData(data, 'jcp', 'test.csv')
        // JCP has no UPC, uses Brand for identification
        expect(items[0].upc).toBe('Invicta')
      })
    })
    ```

    If csv-parse is not installed, add to devDependencies:
    ```bash
    npm install --save-dev csv-parse
    ```
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="retailer-parsing"
    ```
  </verify>
  <done>Integration tests pass for all sample manifests, confirming correct field extraction per retailer</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full test suite
npm test

# TypeScript check
npx tsc --noEmit

# Build extension
npm run build

# Verify no regressions in unified output
# (unified transform should still work since ManifestItem interface unchanged)
```
</verification>

<success_criteria>
- All integration tests pass for sample manifests
- TypeScript compiles without errors
- Extension builds successfully
- ACE UPC extracted correctly
- AMZ ASIN extracted correctly
- ATT "NOT AVAILABLE" produces blank
- BY Quantity column used
- All 10 retailers parse without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-standard-retailer-mappings/02-02-SUMMARY.md`
</output>
