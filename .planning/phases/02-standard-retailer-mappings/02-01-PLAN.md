---
phase: 02-standard-retailer-mappings
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/retailers/field-mappings.ts
  - tests/retailers/field-mappings.test.ts
autonomous: true

must_haves:
  truths:
    - "ACE manifest UPC column extracts to item_number"
    - "AMZ manifest ASIN column extracts to item_number"
    - "ATT manifest with UPC 'NOT AVAILABLE' produces blank item_number"
    - "Null values ('N/A', 'n/a', '-', 'none', '0000000000', 'not available') become blank"
    - "Processing manifests from any of 10 standard retailers produces unified output with correct field extraction"
  artifacts:
    - path: "src/retailers/field-mappings.ts"
      provides: "Retailer field mapping configurations and extraction functions"
      exports: ["getRetailerFieldConfig", "isNullValue", "NULL_VALUES", "RetailerFieldConfig"]
    - path: "tests/retailers/field-mappings.test.ts"
      provides: "Test coverage for field mapping behavior"
      min_lines: 100
  key_links:
    - from: "base-parser.ts"
      to: "field-mappings.ts"
      via: "import { getRetailerFieldConfig, isNullValue } from retailers"
      pattern: "import.*getRetailerFieldConfig.*from.*retailers"
      note: "extractField is internal helper in field-mappings.ts - base-parser uses getRetailerFieldConfig and isNullValue directly"
---

<objective>
Create retailer-specific field mapping configurations that define how each retailer's manifest columns map to unified fields.

Purpose: Enable accurate field extraction from 10 different retailer manifest formats, handling each retailer's unique column naming conventions and null value patterns.

Output: Type-safe retailer configurations with tested null-value handling and column extraction logic.
</objective>

<execution_context>
@C:\Users\Shealtiel\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Shealtiel\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-standard-retailer-mappings/02-CONTEXT.md
@.planning/phases/01-unified-format-foundation/01-01-SUMMARY.md

Source files:
@src/parsers/types.ts
@src/parsers/base-parser.ts

Sample manifests in /csvs folder:
- ACE: UPC, Item #, Item Description, Qty, Unit Retail
- AMZ: ASIN, Item Description, Qty, Unit Retail
- ATT: UPC (with "NOT AVAILABLE"), Item Description, Qty, Unit Retail
- BY: UPC, Item Description, Quantity, Unit Retail
- JCP: Brand, Qty, Unit Retail (no unique identifier)
- QVC: Item #, Item Description, Qty, Unit Retail
- RC: Item #, Item Description, Qty, Unit Retail
- TGT: UPC, Item #, Item Description, Qty, Unit Retail
- B (B-Stock): Item #, Item Description, Qty, Unit Retail
</context>

<feature>
  <name>Retailer Field Mapping Configuration</name>
  <files>src/retailers/field-mappings.ts, tests/retailers/field-mappings.test.ts</files>
  <behavior>
    Null value handling:
    - isNullValue('NOT AVAILABLE') -> true
    - isNullValue('N/A') -> true
    - isNullValue('n/a') -> true (case-insensitive)
    - isNullValue('-') -> true
    - isNullValue('none') -> true
    - isNullValue('0000000000') -> true
    - isNullValue('Valid UPC') -> false
    - isNullValue('12345') -> false

    Retailer config retrieval:
    - getRetailerFieldConfig('ace') -> { itemNumber: ['UPC'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('amz') -> { itemNumber: ['ASIN'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('att') -> { itemNumber: ['UPC'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('by') -> { itemNumber: ['UPC'], productName: ['Item Description'], qty: ['Quantity'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('costco') -> { itemNumber: ['Item #'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('jcp') -> { itemNumber: ['Item #', 'Brand'], productName: ['Brand', 'Subcategory'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('qvc') -> { itemNumber: ['Item #'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('rc') -> { itemNumber: ['Item #', 'UPC'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('tgt') -> { itemNumber: ['UPC', 'Item #'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('tl') -> { itemNumber: ['UPC'], productName: ['Product Name'], qty: ['Quantity', 'Qty'], unitRetail: ['Orig. Retail', 'Unit Retail'] }
    - getRetailerFieldConfig('bstock') -> { itemNumber: ['Item #'], productName: ['Item Description'], qty: ['Qty'], unitRetail: ['Unit Retail'] }
    - getRetailerFieldConfig('unknown') -> default config with fallback columns

    Field extraction with null handling:
    - extractField({ UPC: 'NOT AVAILABLE' }, ['UPC']) -> '' (null value)
    - extractField({ UPC: '123456789' }, ['UPC']) -> '123456789'
    - extractField({ 'Item Description': 'Widget' }, ['Item Description']) -> 'Widget'
    - extractField({ 'Unknown Col': 'value' }, ['Item Description', 'Description']) -> '' (column not found)
  </behavior>
  <implementation>
    1. Define RetailerFieldConfig interface with itemNumber, productName, qty, unitRetail arrays
    2. Define NULL_VALUES constant array with case-normalized values
    3. Implement isNullValue(value: string): boolean - case-insensitive check
    4. Create RETAILER_CONFIGS map with all 10 retailer configurations
    5. Implement getRetailerFieldConfig(retailerId: string): RetailerFieldConfig
    6. Implement extractField(row: RawRow, columnNames: string[]): string - returns first matching column value, applying null-value handling
    7. Export all public functions and types
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for isNullValue, getRetailerFieldConfig, extractField</name>
  <files>tests/retailers/field-mappings.test.ts</files>
  <action>
    Create test file with failing tests for all three functions:

    1. isNullValue tests:
       - Test 'NOT AVAILABLE', 'N/A', 'n/a', '-', 'none', '0000000000' all return true
       - Test 'Valid UPC', '12345', 'Product Name' return false
       - Test case-insensitivity ('n/a' vs 'N/A')

    2. getRetailerFieldConfig tests:
       - Test ACE returns itemNumber: ['UPC']
       - Test AMZ returns itemNumber: ['ASIN']
       - Test TL returns unitRetail: ['Orig. Retail', 'Unit Retail']
       - Test BY returns qty: ['Quantity']
       - Test unknown retailer returns default config

    3. extractField tests (internal helper, test indirectly via getRetailerFieldConfig behavior or export for testing):
       - Test { UPC: 'NOT AVAILABLE' } with ['UPC'] returns ''
       - Test { UPC: '123456789' } with ['UPC'] returns '123456789'
       - Test { 'Unknown Col': 'value' } with ['Item Description'] returns ''

    Import from non-existent file to ensure RED state:
    ```typescript
    import { isNullValue, getRetailerFieldConfig, extractField } from '../../src/retailers/field-mappings'
    ```
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="field-mappings" 2>&1 | grep -E "(FAIL|Cannot find module)"
    ```
    Test should FAIL because field-mappings.ts doesn't exist yet.
  </verify>
  <done>Test file exists with comprehensive test cases, all failing</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement field-mappings.ts to pass all tests</name>
  <files>src/retailers/field-mappings.ts</files>
  <action>
    Create implementation file with minimal code to pass tests:

    1. Define RetailerFieldConfig interface:
       ```typescript
       export interface RetailerFieldConfig {
         itemNumber: string[]
         productName: string[]
         qty: string[]
         unitRetail: string[]
       }
       ```

    2. Define NULL_VALUES constant (case-normalized):
       ```typescript
       export const NULL_VALUES = ['n/a', 'not available', '-', 'none', '0000000000', '']
       ```

    3. Implement isNullValue (exported):
       ```typescript
       export function isNullValue(value: string): boolean {
         return NULL_VALUES.includes(value.toLowerCase().trim())
       }
       ```

    4. Create RETAILER_CONFIGS map with all 10 retailers + bstock:
       - ace, amz, att, by, costco, jcp, qvc, rc, tgt, tl, bstock
       - Each config defines itemNumber, productName, qty, unitRetail column arrays

    5. Implement getRetailerFieldConfig (exported):
       ```typescript
       export function getRetailerFieldConfig(retailerId: string): RetailerFieldConfig {
         return RETAILER_CONFIGS.get(retailerId.toLowerCase()) ?? DEFAULT_CONFIG
       }
       ```

    6. Implement extractField (internal helper, NOT exported to base-parser):
       ```typescript
       export function extractField(row: Record<string, unknown>, columnNames: string[]): string {
         for (const col of columnNames) {
           const value = row[col]
           if (value !== undefined && value !== null) {
             const strValue = String(value).trim()
             return isNullValue(strValue) ? '' : strValue
           }
         }
         return ''
       }
       ```

    Note: extractField is exported for testing but is an internal helper used within field-mappings.ts.
    base-parser.ts will use getRetailerFieldConfig and isNullValue directly, not extractField.
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="field-mappings"
    ```
    All tests should PASS.
  </verify>
  <done>All tests pass, implementation complete</done>
</task>

<task type="auto">
  <name>Task 3: REFACTOR - Verify clean code and TypeScript compilation</name>
  <files>src/retailers/field-mappings.ts, tests/retailers/field-mappings.test.ts</files>
  <action>
    1. Review implementation for any obvious improvements:
       - Ensure consistent naming conventions
       - Remove any redundant code
       - Add JSDoc comments for exported functions

    2. Verify TypeScript compiles without errors:
       ```bash
       npx tsc --noEmit
       ```

    3. Verify exports are correct:
       - getRetailerFieldConfig (public)
       - isNullValue (public)
       - NULL_VALUES (public)
       - RetailerFieldConfig type (public)
       - extractField (exported for testing, but internal use)

    4. Run full test suite to ensure no regressions:
       ```bash
       npm test
       ```
  </action>
  <verify>
    ```bash
    npx tsc --noEmit && npm test -- --testPathPattern="field-mappings"
    ```
    TypeScript compiles and all tests pass.
  </verify>
  <done>Code is clean, typed correctly, all tests pass</done>
</task>

</tasks>

<verification>
After TDD cycle completes:

```bash
# Run tests
npm test -- --testPathPattern="field-mappings"

# Verify TypeScript compiles
npx tsc --noEmit

# Verify exports are accessible
grep -n "export" src/retailers/field-mappings.ts
```
</verification>

<success_criteria>
- All tests pass for null-value detection
- All tests pass for retailer config retrieval (10 retailers)
- All tests pass for field extraction with null handling
- TypeScript compiles without errors
- At least 10 test cases covering edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-standard-retailer-mappings/02-01-SUMMARY.md`
</output>
