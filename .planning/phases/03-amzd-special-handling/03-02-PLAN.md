---
phase: 03-amzd-special-handling
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/parsers/base-parser.ts
  - src/retailers/field-mappings.ts
  - tests/integration/retailer-parsing.test.ts
autonomous: true

must_haves:
  truths:
    - "AMZD manifest produces unified output with correct columns"
    - "AMZD ASIN becomes item_number in unified format"
    - "AMZD Item Title becomes product_name in unified format"
    - "AMZD unit_retail is Lot item price * 4.5"
    - "AMZD integration test passes against real CSV file"
  artifacts:
    - path: "src/retailers/field-mappings.ts"
      provides: "AMZD retailer config"
      contains: "amzd"
    - path: "src/parsers/base-parser.ts"
      provides: "AMZD-aware parsing"
      contains: "amzd"
    - path: "tests/integration/retailer-parsing.test.ts"
      provides: "AMZD integration test"
      contains: "AMZD"
  key_links:
    - from: "src/parsers/base-parser.ts"
      to: "src/parsers/amzd-parser.ts"
      via: "import"
      pattern: "import.*from.*amzd-parser"
    - from: "src/retailers/field-mappings.ts"
      to: "RETAILER_CONFIGS"
      via: "Map entry"
      pattern: "\\['amzd'"
---

<objective>
Integrate AMZD parser into the manifest processing pipeline.

Purpose: Wire the AMZD-specific parsing functions into base-parser so that AMZD manifests are processed with the correct column extraction and price calculation.

Output: Working AMZD parsing in the extension, verified by integration test against the sample AMZD CSV.
</objective>

<execution_context>
@C:\Users\Shealtiel\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Shealtiel\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-amzd-special-handling/03-CONTEXT.md
@.planning/phases/03-amzd-special-handling/03-01-SUMMARY.md
@src/parsers/base-parser.ts
@src/parsers/amzd-parser.ts
@src/retailers/field-mappings.ts
@tests/integration/retailer-parsing.test.ts
@csvs/AMZD_161-Units-Pc-Electronics-Wireless-RD.csv
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AMZD config to RETAILER_CONFIGS</name>
  <files>src/retailers/field-mappings.ts</files>
  <action>
    Add 'amzd' entry to RETAILER_CONFIGS Map in field-mappings.ts:

    ```typescript
    // AMZD (Amazon Direct): Uses ASIN, special price calculation handled in amzd-parser
    [
      'amzd',
      {
        itemNumber: ['ASIN'],
        productName: ['Item Title', 'Model', 'Brand'],
        qty: ['Qty'],
        unitRetail: ['Lot item price'],
      },
    ],
    ```

    Place after existing 'amz' entry for logical grouping.
    Note: The actual price multiplier is applied in amzd-parser.ts, not here.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    grep -n "amzd" src/retailers/field-mappings.ts
    ```
  </verify>
  <done>RETAILER_CONFIGS contains 'amzd' entry with ASIN, Item Title, Qty, Lot item price mappings</done>
</task>

<task type="auto">
  <name>Task 2: Add AMZD case to getFieldMapping</name>
  <files>src/parsers/base-parser.ts</files>
  <action>
    Update base-parser.ts to handle 'amzd' in getFieldMapping:

    1. Add 'amzd' case to getFieldMapping switch (before default):
       ```typescript
       case 'amzd':
         return getAmzdFieldMapping()
       ```

    2. Create getAmzdFieldMapping function that returns the standard field mapping:
       ```typescript
       function getAmzdFieldMapping(): FieldMapping {
         return {
           itemNumber: ['ASIN'],
           productName: ['Item Title', 'Model', 'Brand'],
           qty: ['Qty'],
           unitRetail: ['Lot item price'],
         }
       }
       ```

    Note: The actual price multiplier and misalignment handling happens in
    parseAmzdManifest (Task 3), not here. This just sets up the header mappings.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    grep -n "getAmzdFieldMapping\|case 'amzd'" src/parsers/base-parser.ts
    ```
  </verify>
  <done>getFieldMapping returns AMZD field mapping when site is 'amzd'</done>
</task>

<task type="auto">
  <name>Task 3: Create parseAmzdManifest function</name>
  <files>src/parsers/base-parser.ts</files>
  <action>
    Create the AMZD-specific manifest parsing function:

    1. Import parseAmzdRow and calculateAmzdUnitRetail from amzd-parser:
       ```typescript
       import { parseAmzdRow, calculateAmzdUnitRetail } from './amzd-parser'
       ```

    2. Create parseAmzdManifest function:
       ```typescript
       function parseAmzdManifest(rawData: Record<string, unknown>[], filename: string): ManifestItem[] {
         if (rawData.length === 0) return []

         const headers = Object.keys(rawData[0])
         const items: ManifestItem[] = []

         for (const row of rawData) {
           const cells = Object.values(row)
           const parsed = parseAmzdRow(row, cells, headers)

           if (parsed) {
             items.push({
               // Map AmzdParsedRow to ManifestItem
               upc: parsed.asin,
               productName: parsed.productName,
               quantity: parsed.qty,
               unitRetail: parsed.unitRetail,
               // ... other required fields with defaults
             })
           }
         }

         return items
       }
       ```

    Key points:
    - Extracts headers from first row
    - Calls parseAmzdRow for each row with row object, cell values, and headers
    - parseAmzdRow handles misalignment detection and right-anchor extraction
    - Filters out null results (empty/invalid rows)
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    grep -n "parseAmzdManifest" src/parsers/base-parser.ts
    ```
  </verify>
  <done>parseAmzdManifest function created with AMZD-specific row handling</done>
</task>

<task type="auto">
  <name>Task 4: Wire parseAmzdManifest into parseManifestData</name>
  <files>src/parsers/base-parser.ts</files>
  <action>
    Route 'amzd' site to the AMZD-specific parser:

    In parseManifestData, add special handling for 'amzd' site before the standard loop:
    ```typescript
    export function parseManifestData(
      rawData: Record<string, unknown>[],
      site: string,
      filename: string
    ): ManifestItem[] {
      // AMZD requires special handling due to misaligned columns
      if (site === 'amzd') {
        return parseAmzdManifest(rawData, filename)
      }

      // ... existing standard parsing logic
    }
    ```

    This ensures:
    - AMZD manifests use ASIN scanning (not column position)
    - Price is multiplied by 4.5
    - Misaligned rows are handled via right-anchor extraction
    - All other retailers continue using standard parsing
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    grep -n "site === 'amzd'" src/parsers/base-parser.ts
    ```
  </verify>
  <done>parseManifestData routes 'amzd' site to parseAmzdManifest</done>
</task>

<task type="auto">
  <name>Task 5: Add AMZD integration test</name>
  <files>tests/integration/retailer-parsing.test.ts</files>
  <action>
    Add integration test for AMZD manifest parsing:

    ```typescript
    describe('AMZD (Amazon Direct)', () => {
      it('should parse AMZD manifest with correct field mappings', async () => {
        const csvPath = path.join(__dirname, '../../csvs/AMZD_161-Units-Pc-Electronics-Wireless-RD.csv')
        const rows = await loadCsv(csvPath)

        const items = parseManifestData(rows, 'amzd', 'amzd-test.csv')

        // Should have items
        expect(items.length).toBeGreaterThan(0)

        // First item should have ASIN as item_number (upc field)
        const firstItem = items[0]
        expect(firstItem.upc).toBe('B083WFQC1C')

        // Product name from Item Title
        expect(firstItem.productName).toContain('GIGABYTE X870E AORUS')

        // unit_retail should be Lot item price * 4.5
        // First row: $188.00 * 4.5 = $846.00
        expect(firstItem.unitRetail).toBe(846)

        // Quantity
        expect(firstItem.quantity).toBe(1)
      })

      it('should calculate unit_retail correctly with 4.5 multiplier', async () => {
        const csvPath = path.join(__dirname, '../../csvs/AMZD_161-Units-Pc-Electronics-Wireless-RD.csv')
        const rows = await loadCsv(csvPath)

        const items = parseManifestData(rows, 'amzd', 'amzd-test.csv')

        // Find Apple Pencil row (6 qty at $17.75)
        // $17.75 * 4.5 = $79.875 -> rounded to $79.88
        const applePencil = items.find(i => i.upc === 'B0CL7J12YK')
        expect(applePencil).toBeDefined()
        expect(applePencil!.unitRetail).toBeCloseTo(79.88, 2)
        expect(applePencil!.quantity).toBe(6)
      })
    })
    ```

    Add this after the existing retailer tests (TL, QVC, etc.)
  </action>
  <verify>
    ```bash
    npm test -- --testPathPattern="retailer-parsing" --testNamePattern="AMZD"
    ```
  </verify>
  <done>AMZD integration tests pass, verifying ASIN extraction, product name mapping, and 4.5x price calculation</done>
</task>

<task type="auto">
  <name>Task 6: Verify all tests pass</name>
  <files>-</files>
  <action>
    Run full test suite to ensure AMZD integration doesn't break existing functionality:

    1. Run all tests: `npm test`
    2. Verify TypeScript compiles: `npx tsc --noEmit`
    3. Verify extension builds: `npm run build`

    Expected: All existing tests continue to pass, new AMZD tests pass.
  </action>
  <verify>
    ```bash
    npm test && npx tsc --noEmit && npm run build
    ```
  </verify>
  <done>All tests pass, TypeScript compiles, extension builds successfully</done>
</task>

</tasks>

<verification>
```bash
# Full verification
npm test && npx tsc --noEmit && npm run build

# AMZD-specific checks
npm test -- --testPathPattern="amzd" --coverage
npm test -- --testPathPattern="retailer-parsing" --testNamePattern="AMZD"

# Verify AMZD in field-mappings
grep -n "amzd" src/retailers/field-mappings.ts

# Verify AMZD integration in base-parser
grep -n "amzd\|parseAmzdRow" src/parsers/base-parser.ts
```
</verification>

<success_criteria>
- AMZD integration tests pass
- All existing retailer tests continue to pass
- TypeScript compiles without errors
- Extension builds successfully
- AMZD manifest processing produces correct unified output:
  - item_number = ASIN (e.g., B083WFQC1C)
  - product_name = Item Title
  - unit_retail = Lot item price * 4.5
  - qty = Qty column value
</success_criteria>

<output>
After completion, create `.planning/phases/03-amzd-special-handling/03-02-SUMMARY.md`
</output>
